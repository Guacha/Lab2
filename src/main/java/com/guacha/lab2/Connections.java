/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.guacha.lab2;

import java.awt.Point;
import java.util.ArrayList;
import java.util.Map;
import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JSpinner;
import javax.swing.SpinnerNumberModel;
import javax.swing.border.BevelBorder;

/**
 * Clase que se encarga de las alteraciones del grafo, es decir, adición, edición y eliminación de vértices <p>
 * Esta clase tiene dos constructores, uno pensado para la edición, y otro para la adición <p>
 * Esto se hace con el proposito de reutilizar esta ventana para multiples propósitos
 * @author Guacha
 */
public class Connections extends javax.swing.JFrame {

    /**
     * Creates new form Connections
     */
    Graphe g;
    Mapa m;
    Point p;
    ArrayList<JSpinner> cons;
    Sommet edit;
    /**
     * El constructor de esta ventana para la creación de vértices nuevos. <p>
     * En este constructor se deshabilita el botón de borrar vértice y se acomodan los elementos
     * @param g El grafo sobre el que se va a trabajar
     * @param m La ventana en la que se está dibujando, esta instancia es necesaria en esta ventana
     * @param p El punto sobre se va a dibujar el vertice nuevo (Si se crea)
     */
    public Connections(Graphe g, Mapa m, Point p) {
        initComponents();
        this.g = g;
        this.m = m;
        this.p = p;
        initialiserNouvelle();
    }
    
    /**
     * El constructor de esta ventana para la edición de vértices existentes. <p>
     * En este constructor se habilita el botón de borrar vértice y se acomodan los elementos
     * @param graphe el grafo sobre el que se va a trabajar
     * @param m La ventana en la que se está dibujando, es necesaria una instancia de esa ventana
     * @param sel El vértice que se está editando
     */
    public Connections(Graphe graphe, Mapa m, Sommet sel) {
        initComponents();
        edit = sel;
        this.g = graphe;
        this.m = m;
        initialiserExistent();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        buttonGroup1 = new javax.swing.ButtonGroup();
        finishButton = new javax.swing.JButton();
        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        nomField = new javax.swing.JTextField();
        jLabel2 = new javax.swing.JLabel();
        radioBus = new javax.swing.JRadioButton();
        radioMetro = new javax.swing.JRadioButton();
        radioBusNuit = new javax.swing.JRadioButton();
        radioMulti = new javax.swing.JRadioButton();
        holdPane = new javax.swing.JScrollPane();
        chkPanel = new javax.swing.JPanel();
        elimSomm = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);

        finishButton.setText("Crear Vértice");
        finishButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                finishButtonActionPerformed(evt);
            }
        });

        jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder(new BevelBorder(BevelBorder.RAISED), "Información del Vértice"));

        jLabel1.setText("Nombre del Vértice");

        jLabel2.setText("Tipo de Estación");

        buttonGroup1.add(radioBus);
        radioBus.setSelected(true);
        radioBus.setText("Bus");

        buttonGroup1.add(radioMetro);
        radioMetro.setText("Metro");

        buttonGroup1.add(radioBusNuit);
        radioBusNuit.setText("Bus Nocturno");

        buttonGroup1.add(radioMulti);
        radioMulti.setText("Estación Multipropósito");
        radioMulti.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                radioMultiActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(nomField)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel1)
                            .addComponent(jLabel2)
                            .addComponent(radioBus)
                            .addComponent(radioMetro)
                            .addComponent(radioBusNuit)
                            .addComponent(radioMulti))
                        .addGap(0, 56, Short.MAX_VALUE)))
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(nomField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jLabel2)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(radioBus)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(radioMetro)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(radioBusNuit)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(radioMulti)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        chkPanel.setBorder(javax.swing.BorderFactory.createTitledBorder(new BevelBorder(BevelBorder.RAISED), "Configurar Conexiones"));

        javax.swing.GroupLayout chkPanelLayout = new javax.swing.GroupLayout(chkPanel);
        chkPanel.setLayout(chkPanelLayout);
        chkPanelLayout.setHorizontalGroup(
            chkPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 236, Short.MAX_VALUE)
        );
        chkPanelLayout.setVerticalGroup(
            chkPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 260, Short.MAX_VALUE)
        );

        holdPane.setViewportView(chkPanel);

        elimSomm.setText("Eliminar Vértice");
        elimSomm.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                elimSommActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(finishButton, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(holdPane))
                    .addComponent(elimSomm, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(holdPane, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE))
                .addGap(18, 18, 18)
                .addComponent(finishButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(elimSomm)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    //La madre de todos los métodos, me quería morir haciendolo
    private void finishButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_finishButtonActionPerformed
        //este condicional es una doble verificación para saber si estamos editando o añadiendo (por si acaso :v)
        if (edit == null) { //Si edit es nulo, quiere decir que entramos por el constructor de añadir
            TypeSommet type = getTypeSommet();
            if (!nomField.getText().isEmpty()) {
                Sommet s = new Sommet(nomField.getText(), p, type);
                g.addVert(s); //Creamos y añadimos el vértice

                if (isConnected()) { //Verificamos si el vertice no está aislado
                    cons.stream().filter((con) -> ((int)con.getValue() > 0)).forEachOrdered((con) -> { //Expresión lambda que retorna cada JSpinner cuyo número es mayor a 0
                        Sommet connecte = g.getSommet(con.getName()); 
                        g.addArete(s, connecte, (int)con.getValue()); //Añade arista por cada JSpinner
                    });
                }
                m.dessinerGraphe();
                m.showInfo(s);
                System.out.println(g.isCyclic());
                this.dispose();
            }
        } else { //Si entramos por el otro constructor (Constructor de Edición de arista)
            TypeSommet type = getTypeSommet();
            if (!nomField.getText().isEmpty()) {
                for (JSpinner con : cons) { //Este ciclo recorre todos los Jspinners y revisa cuales cambiaron
                    Sommet rel = g.getSommet(con.getName());
                    if ((int)con.getValue() > 0) { //Si el valor no es cero, existe una arista
                        if (g.existArete(edit, rel)) { //Verificamos si hay una arista, si la hay, se debe editar el peso
                            if (g.getPoids(edit, rel) != (int)con.getValue()) {
                                g.setPoids(edit, rel, (int)con.getValue());
                            }
                        } else { //Si la arista no existe, se debe crear
                            g.addArete(edit, rel, (int)con.getValue());
                        }
                    } else { //En caso de que el Spinner esté en 0, no debe existir arista
                        if (g.existArete(edit, rel)) { //Si existe una arista, se debe eliminar
                            g.quitArete(edit, rel);
                        }
                    }
                }
                edit.nombre = nomField.getText();
                edit.type = type;
            }
            m.dessinerGraphe();
            m.showInfo(edit);
            System.out.println(g.isCyclic());
            this.dispose();
        }
    }//GEN-LAST:event_finishButtonActionPerformed

    private void radioMultiActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_radioMultiActionPerformed

    }//GEN-LAST:event_radioMultiActionPerformed

    private void elimSommActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_elimSommActionPerformed
        //este condicional es una doble verificación para saber si estamos editando o añadiendo (por si acaso :v)
        if (edit != null) {//Si edit no es nulo, quiere decir que entramos por el constructor de editar
            if (JOptionPane.showConfirmDialog(null, "Seguro que desea eliminar el vértice " + edit.nombre,
                    "Eliminación de vértice", JOptionPane.OK_CANCEL_OPTION, JOptionPane.WARNING_MESSAGE,
                    null) == JOptionPane.OK_OPTION) { //Condicional que saca un JOption para verificar si el usuario realmente desea eliminar el vértice
                g.quitVert(edit);
            }
            m.dessinerGraphe();
            m.getOutput().setText("Vértice " + edit.nombre + " eliminado!"); //Se escribe en el output de la ventana principal
            System.out.println(g.isCyclic());
            this.dispose();
        }
    }//GEN-LAST:event_elimSommActionPerformed
     /**
      * Función para inicializar la ventana cuando se desea añadir un vértice <p>
      * Se añaden JSpinners, uno por cada vértice, para representar las conexiones con peso entre cada par de vértices
      */
    private void initialiserNouvelle() {
        elimSomm.setVisible(false);
        cons = new ArrayList<>();
        this.setTitle("Nuevo vértice");
        chkPanel.setLayout(new BoxLayout(chkPanel, BoxLayout.Y_AXIS));
        g.getSommAdj().keySet().forEach((sommet) -> {
            chkPanel.add(new JLabel("Conexión con " + sommet.nombre));
            SpinnerNumberModel model = new SpinnerNumberModel(0, 0, 10000, 1);
            JSpinner c = new JSpinner(model);
            c.setName(sommet.nombre);
            c.setEditor(new JSpinner.DefaultEditor(c));
            cons.add(c);
            chkPanel.add(c);
        });
        chkPanel.revalidate();
        chkPanel.repaint();
    }
    /**
      * Función para inicializar la ventana cuando se desea editar un vértice <p>
      * Se añaden JSpinners, uno por cada vértice, para representar las conexiones con peso entre cada par de vértices. <p>
      * En este caso, se hacen varias cosas para alterar el Look and Feel, se añade un botón para eliminar el vértice, 
      * el titulo de la ventana cambia, y ciertas opciones ya están preseleccionadas.
      */
    private void initialiserExistent() {
        nomField.setText(edit.nombre);
        finishButton.setText("Editar Vertice");
        cons = new ArrayList<>();
        this.setTitle("Editar vertice: " + edit.nombre);
        chkPanel.setLayout(new BoxLayout(chkPanel, BoxLayout.Y_AXIS));
        for (Map.Entry<Sommet, Map<Sommet, Integer>> entry : g.getSommAdj().entrySet()) {
            if (!entry.getKey().equals(edit)) {
                chkPanel.add(new JLabel("Conexión con " + entry.getKey().nombre));
                int pesoAct = getPesoSommets(edit, entry.getKey());
                SpinnerNumberModel model = new SpinnerNumberModel(pesoAct, 0, 10000, 1);
                JSpinner c = new JSpinner(model);
                c.setName(entry.getKey().nombre);
                cons.add(c);
                chkPanel.add(c);
            }                
        }
        chkPanel.revalidate();
        chkPanel.repaint();
    }
    
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.ButtonGroup buttonGroup1;
    private javax.swing.JPanel chkPanel;
    private javax.swing.JButton elimSomm;
    private javax.swing.JButton finishButton;
    private javax.swing.JScrollPane holdPane;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JTextField nomField;
    private javax.swing.JRadioButton radioBus;
    private javax.swing.JRadioButton radioBusNuit;
    private javax.swing.JRadioButton radioMetro;
    private javax.swing.JRadioButton radioMulti;
    // End of variables declaration//GEN-END:variables

    private TypeSommet getTypeSommet() {
        if (radioBus.isSelected()) {
            return TypeSommet.STATION_BUS;
        } else if (radioMetro.isSelected()) {
            return TypeSommet.STATION_METRO;
        } else if (radioBusNuit.isSelected()) {
            return TypeSommet.STATION_BUSDENUIT;
        } else {
            return TypeSommet.STATION_MULTI;
        }
    }
    
    private boolean isConnected() {
        if (cons.stream().anyMatch((con) -> ((int)con.getValue() > 0))) {
            return true;
        }
        return false;
    }

    private int getPesoSommets(Sommet edit, Sommet key) {
        Map<Sommet, Integer> rels = g.getSommAdj().get(edit);
        for (Map.Entry<Sommet, Integer> entry : rels.entrySet()) {
            if (entry.getKey().equals(key)) {
                return entry.getValue();
            }
        }
        return 0;
    }
}
